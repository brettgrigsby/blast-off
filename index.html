<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Block Booster</title>
    <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
    <script>
      (() => {
        var __defProp = Object.defineProperty;
        var __getOwnPropNames = Object.getOwnPropertyNames;
        var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
        var __hasOwnProp = Object.prototype.hasOwnProperty;
        var __moduleCache = /* @__PURE__ */ new WeakMap();
        var __toCommonJS = (from) => {
          var entry = __moduleCache.get(from),
            desc;
          if (entry) return entry;
          entry = __defProp({}, "__esModule", { value: true });
          if ((from && typeof from === "object") || typeof from === "function")
            __getOwnPropNames(from).map(
              (key) =>
                !__hasOwnProp.call(entry, key) &&
                __defProp(entry, key, {
                  get: () => from[key],
                  enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable,
                }),
            );
          __moduleCache.set(from, entry);
          return entry;
        };
        var __export = (target, all) => {
          for (var name in all)
            __defProp(target, name, {
              get: all[name],
              enumerable: true,
              configurable: true,
              set: (newValue) => (all[name] = () => newValue),
            });
        };

        // src/index.ts
        var exports_src = {};
        __export(exports_src, {
          sdk: () => sdk,
          FarcadeSDK: () => FarcadeSDK,
        });

        class FarcadeSDK {
          isClient;
          target = null;
          eventListeners = new Map();
          readyPromiseResolve = null;
          purchasePromiseResolve = null;
          _gameInfo;
          _gameState;
          constructor() {
            this.isClient = typeof window !== "undefined";
            this.target = this.isClient ? window.parent : null;
            if (this.isClient) {
              window.addEventListener("message", this.handleMessage);
              window.addEventListener("error", this.handleGlobalError);
              window.addEventListener("unhandledrejection", this.handleUnhandledRejection);
              this.sendMessage("ready", undefined);
            }
          }
          on(eventType, callback) {
            if (!this.eventListeners.has(eventType)) {
              this.eventListeners.set(eventType, new Set());
            }
            this.eventListeners.get(eventType)?.add(callback);
          }
          off(eventType, callback) {
            this.eventListeners.get(eventType)?.delete(callback);
          }
          setTarget(target) {
            this.target = target;
          }
          get purchasedItems() {
            return this._gameInfo?.purchasedItems || [];
          }
          get gameInfo() {
            return this._gameInfo;
          }
          get gameState() {
            return this._gameState;
          }
          get players() {
            return this._gameInfo?.players;
          }
          get player() {
            return this._gameInfo?.player;
          }
          get isReady() {
            return !!this._gameInfo;
          }
          ready = () => {
            if (this._gameInfo) {
              return Promise.resolve(this._gameInfo);
            }
            return new Promise((resolve) => {
              this.readyPromiseResolve = resolve;
            });
          };
          purchase = (data) => {
            this.sendMessage("purchase", data);
            return new Promise((resolve) => {
              this.purchasePromiseResolve = resolve;
            });
          };
          reportError = (data) => {
            this.sendMessage("error", data);
          };
          hapticFeedback = () => {
            this.sendMessage("haptic_feedback", undefined);
          };
          hasItem = (item) => {
            return this._gameInfo?.purchasedItems.includes(item) || false;
          };
          singlePlayer = {
            actions: {
              ready: this.ready,
              hapticFeedback: this.hapticFeedback,
              reportError: this.reportError,
              purchase: this.purchase,
              gameOver: (data) => {
                this.sendMessage("game_over", data);
              },
              saveGameState: (data) => {
                this.sendMessage("save_game_state", data);
              },
            },
          };
          multiplayer = {
            actions: {
              ...this.singlePlayer.actions,
              gameOver: (data) => {
                this.sendMessage("multiplayer_game_over", data);
              },
              refuteGameState: (data) => {
                this.sendMessage("refute_game_state", data);
              },
              saveGameState: (data) => {
                this.sendMessage("multiplayer_save_game_state", data);
              },
            },
          };
          emit(eventType, data) {
            if (eventType === "game_info") {
              const eventData = data;
              this._gameInfo = eventData;
              if (!this._gameState && eventData.initialGameState) {
                this._gameState = eventData.initialGameState.gameState;
              }
              if (this.readyPromiseResolve) {
                this.readyPromiseResolve(this._gameInfo);
                this.readyPromiseResolve = null;
              }
            }
            if (eventType === "purchase_complete" && this.purchasePromiseResolve) {
              this.purchasePromiseResolve(data);
              this.purchasePromiseResolve = null;
            }
            if (eventType === "game_state_updated") {
              const eventData = data;
              if (eventData) {
                this._gameState = eventData.gameState;
              } else {
                this._gameState = null;
              }
            }
            for (const callback of this.eventListeners.get(eventType) || []) {
              callback(data);
            }
          }
          handleMessage = (event) => {
            if (event.data?.type !== "game_event") return;
            this.emit(event.data.event.type, event.data.event.data);
          };
          sendMessage = (type, data) => {
            if (!this.isClient || !this.target) return;
            const gameEvent = { type: "game_event", event: { type, data } };
            this.target.postMessage(gameEvent, "*");
          };
          handleGlobalError = (event) => {
            this.sendMessage("error", {
              message: event.message || "Unknown error",
              source: event.filename,
              lineno: event.lineno,
              colno: event.colno,
              error: event.error,
            });
          };
          handleUnhandledRejection = (event) => {
            const error = event.reason instanceof Error ? event.reason : new Error(String(event.reason));
            this.sendMessage("error", {
              message: error.message,
              error,
            });
          };
        }
        var sdk = new FarcadeSDK();
        if (typeof window !== "undefined") {
          window.FarcadeSDK = sdk;
        }
      })();

      //# debugId=B2BEF3F2701F9B8064756E2164756E21
    </script>
    <style>
      body {
        margin: 0;
        padding: 0;
        display: flex;
        justify-content: center;
        align-items: center;
      }
      
      canvas {
        outline: none;
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script type="module">
      // Development only - build script replaces this entire block
      if (import.meta.env.DEV) {
        // Load CSS for dev dashboard
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = '/node_modules/@insidethesim/remix-dev/dist/styles/remix-dev.css'
        document.head.appendChild(link)

        import('@insidethesim/remix-dev/dev-init')

        // Only load the game in iframe, not in top window (dashboard handles iframes)
        if (window !== window.top) {
          import('/src/main.ts')
        }
      }
    </script>
  </body>
</html>